{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }


	"Basic Code": {
	"prefix": "bs",
	"body": [
		"#include <bits/stdc++.h>",
		"using namespace std;",
		"#define ll long long",
		"",
		"const int MOD = 1e9 + 7;",
		"",
		"void solve(){",
		"   $0 ",
		"}",
		"",
		"int MULTIPLE_TEST_CASES = 0;",
		"int main(){",
		"    ios_base :: sync_with_stdio(false); cin.tie(0); cout.tie(0);",
		"    int t = 1;",
		"    if(MULTIPLE_TEST_CASES) cin >> t;",
		"    while(t--) solve();",
		"    return 0;",
		"}"
	],
	"description": "Basic Code"
	},
	"Basic Code Multiple test case": {
	"prefix": "ms",
	"body": [
		"#include <bits/stdc++.h>",
		"using namespace std;",
		"#define ll long long",
		"",
		"const int MOD = 1e9 + 7;",
		"",
		"void solve(){",
		"   $0 ",
		"}",
		"",
		"int MULTIPLE_TEST_CASES = 1;",
		"int main(){",
		"    ios_base :: sync_with_stdio(false); cin.tie(0); cout.tie(0);",
		"    int t = 1;",
		"    if(MULTIPLE_TEST_CASES) cin >> t;",
		"    while(t--) solve();",
		"    return 0;",
		"}"
	],
	"description": "Basic Code"
	},

	"Lazy Segment Tree": {
	"prefix": "lazysegment",
	"body": [
		"template<class Info, class Tag>",
		"struct LazySegmentTree {",
		"    int n;",
		"    std::vector<Info> info;",
		"    std::vector<Tag> tag;",
		"",
		"    LazySegmentTree() : n(0) {}",
		"",
		"    LazySegmentTree(int n_, Info v_ = Info()) {",
		"        init(n_, v_);",
		"    }",
		"",
		"    template<class T>",
		"    LazySegmentTree(std::vector<T> init_) {",
		"        init(init_);",
		"    }",
		"",
		"    void init(int n_, Info v_ = Info()) {",
		"        init(std::vector<Info>(n_, v_));",
		"    }",
		"",
		"    template<class T>",
		"    void init(std::vector<T> init_) {",
		"        n = init_.size();",
		"        int sz = (1 << (std::__lg(n - 1) + 1));",
		"        info.assign(sz * 2, Info());",
		"        tag.assign(sz * 2, Tag());",
		"",
		"        std::function<void(int, int, int)> build = [&](int v, int l, int r) {",
		"            if (l == r) {",
		"                info[v] = init_[l];",
		"                return;",
		"            }",
		"            int m = (l + r) / 2;",
		"            build(v << 1, l, m);",
		"            build(v << 1 | 1, m + 1, r);",
		"            info[v] = info[v << 1] + info[v << 1 | 1];",
		"        };",
		"        build(1, 0, n - 1);",
		"    }",
		"",
		"    void apply(int v, int l, int r, const Tag &t) {",
		"        info[v].apply(l, r, t);",
		"        tag[v].apply(t);",
		"    }",
		"",
		"    void push_down(int v, int l, int r) {",
		"        if (!tag[v].hasTag()) return;",
		"        int m = (l + r) / 2;",
		"        apply(v << 1, l, m, tag[v]);",
		"        apply(v << 1 | 1, m + 1, r, tag[v]);",
		"        tag[v] = Tag(); // clear",
		"    }",
		"",
		"    void range_update(int v, int l, int r, int ql, int qr, const Tag &t) {",
		"        if (qr < l || r < ql) return;",
		"        if (ql <= l && r <= qr) {",
		"            apply(v, l, r, t);",
		"            return;",
		"        }",
		"        push_down(v, l, r);",
		"        int m = (l + r) / 2;",
		"        range_update(v << 1, l, m, ql, qr, t);",
		"        range_update(v << 1 | 1, m + 1, r, ql, qr, t);",
		"        info[v] = info[v << 1] + info[v << 1 | 1];",
		"    }",
		"",
		"    Info range_query(int v, int l, int r, int ql, int qr) {",
		"        if (qr < l || r < ql) return Info();",
		"        if (ql <= l && r <= qr) return info[v];",
		"        push_down(v, l, r);",
		"        int m = (l + r) / 2;",
		"        return range_query(v << 1, l, m, ql, qr) + range_query(v << 1 | 1, m + 1, r, ql, qr);",
		"    }",
		"",
		"    void point_update(int v, int l, int r, int i, const Info &x) {",
		"        if (l == r) {",
		"            info[v] = x;",
		"            return;",
		"        }",
		"        push_down(v, l, r);",
		"        int m = (l + r) / 2;",
		"        if (i <= m) point_update(v << 1, l, m, i, x);",
		"        else point_update(v << 1 | 1, m + 1, r, i, x);",
		"        info[v] = info[v << 1] + info[v << 1 | 1];",
		"    }",
		"",
		"    Info point_query(int v, int l, int r, int i) {",
		"        if (l == r) return info[v];",
		"        push_down(v, l, r);",
		"        int m = (l + r) / 2;",
		"        if (i <= m) return point_query(v << 1, l, m, i);",
		"        else return point_query(v << 1 | 1, m + 1, r, i);",
		"    }",
		"",
		"    Info point_query(int i) {",
		"        return point_query(1, 0, n - 1, i);",
		"    }",
		"",
		"    Info range_query(int l, int r) {",
		"        return range_query(1, 0, n - 1, l, r);",
		"    }",
		"",
		"    void point_update(int i, const Info &x) {",
		"        point_update(1, 0, n - 1, i, x);",
		"    }",
		"",
		"    void range_update(int l, int r, const Tag &t) {",
		"        range_update(1, 0, n - 1, l, r, t);",
		"    }",
		"};",
		"",
		"struct Tag {",
		"    long long val = 0;",
		"    bool valid = false;",
		"",
		"    void apply(const Tag &t) {",
		"        val = t.val;",
		"        valid = true;",
		"    }",
		"",
		"    bool hasTag() const {",
		"        return valid;",
		"    }",
		"};",
		"",
		"struct Info {",
		"    long long val = 0;",
		"    int len = 1;",
		"",
		"    Info() {}",
		"    Info(long long v) : val(v) {}",
		"    ",
		"    void apply(int l, int r, const Tag &t) {",
		"        val = 1LL * (r - l + 1) * t.val;",
		"    }",
		"",
		"    friend Info operator+(const Info &a, const Info &b) {",
		"        Info res;",
		"        res.val = a.val + b.val;",
		"        return res;",
		"    }",
		"};"
	],
	"description": "Lazy Segment Tree"
	},

	"Segment Tree": {
	"prefix": "segmenttree",
	"body": [
		" ",
		"template<class Info>",
		"struct SegmentTree {",
		"    int n;",
		"    std::vector<Info> info;",
		" ",
		"    SegmentTree() : n(0) {}",
		" ",
		"    SegmentTree(int n_, Info v_ = Info()) {",
		"        init(n_, v_);",
		"    }",
		" ",
		"    template<class T>",
		"    SegmentTree(std::vector<T> init_) {",
		"        init(init_);",
		"    }",
		" ",
		"    void init(int n_, Info v_ = Info()) {",
		"        init(std::vector<Info>(n_, v_));",
		"    }",
		" ",
		"    template<class T>",
		"    void init(std::vector<T> init_) {",
		"        n = init_.size();",
		"        int sz = (1 << (std::__lg(n - 1) + 1));",
		"        info.assign(sz * 2, Info());",
		"        std::function<void(int, int, int)> build = [&](int v, int l, int r) {",
		"            if (l == r) {",
		"                info[v] = init_[l];",
		"                return;",
		"            }",
		"            int m = (l + r) / 2;",
		"            build(v + v, l, m);",
		"            build(v + v + 1, m + 1, r);",
		"            info[v] = info[v + v] + info[v + v + 1];",
		"        };",
		"        build(1, 0, n - 1);",
		"    }",
		" ",
		"    Info range_query(int v, int l, int r, int tl, int tr) {",
		"        if (r < tl || l > tr) {",
		"            return Info();",
		"        }",
		"        if (l >= tl && r <= tr) {",
		"            return info[v];",
		"        }",
		"        int m = (l + r) / 2;",
		"        return range_query(v + v, l, m, tl, tr) + range_query(v + v + 1, m + 1, r, tl, tr);",
		"    } ",
		"",
		"    int findKthOne(int v, int l, int r, int x, int minl){",
		"        if(info[v].val < x || r < minl) return -1;",
		"        if(l == r) return l;",
		"        int m = (l + r) / 2;",
		"        int ind = findKthOne(v + v, l, m, x, minl);",
		"        if(ind != -1) return ind;",
		"        return findKthOne(v + v + 1, m + 1, r, x, minl);",
		"    }    ",
		" ",
		"    void point_update(int v, int l, int r, int i, const Info &x) {",
		"        if (l == r) {",
		"            info[v] = x;",
		"            return;",
		"        }",
		"        int m = (l + r) / 2;",
		"        if (i <= m) {",
		"            point_update(v + v, l, m, i, x);",
		"        } else {",
		"            point_update(v + v + 1, m + 1, r, i, x);",
		"        }",
		"        info[v] = info[v + v] + info[v + v + 1];",
		"    }    ",
		" ",
		"    Info point_query(int v, int l, int r, int i) {",
		"        if (l == r) {",
		"            return info[v];",
		"        }",
		"        int m = (l + r) / 2;",
		"        if (i <= m) {",
		"            return point_query(v + v, l, m, i);",
		"        } else {",
		"            return point_query(v + v + 1, m + 1, r, i);",
		"        }",
		"    }",
		" ",
		"    Info point_query(int i) {",
		"        return point_query(1, 0, n - 1, i);",
		"    }",
		"",
		"    Info range_query(int l, int r) {",
		"        return range_query(1, 0, n - 1, l, r);",
		"    }",
		"",
		"    void point_update(int i, const Info &x) {",
		"        point_update(1, 0, n - 1, i, x);",
		"    }",
		"",
		"    int findKthOne(int x, int minl){",
		"        return findKthOne(1, 0, n - 1, x, minl);",
		"    }",
		"};",
		" ",
		"struct Info {",
		"    long long val;",
		" ",
		"    Info() : val(0) {}",
		" ",
		"    Info(long long v) : val(v) {}",
		"};",
		" ",
		"Info operator+(const Info &a, const Info &b) {",
		"    Info res;",
		"    res.val = a.val + b.val;",
		"    return res;",
		"}"
	],
	"description": "Segment Tree"
	},

	"KMP Algorithm": {
	"prefix": "kmpalgorithm",
	"body": [
		"vector<int> kmp_algorithm(string s) {",
		"    int n = (int)s.length();",
		"    vector<int> pi(n);",
		"    for (int i = 1; i < n; i++) {",
		"        int j = pi[i-1];",
		"        while (j > 0 && s[i] != s[j])",
		"            j = pi[j-1];",
		"        if (s[i] == s[j])",
		"            j++;",
		"        pi[i] = j;",
		"    }",
		"    return pi;",
		"}"
	],
	"description": "KMP Algorithm"
	},

	"Z Algorithm": {
	"prefix": "zalgorithm",
	"body": [
		"vector<int> z_algorithm(string s) {",
		"    int n = s.size();",
		"    vector<int> z(n);",
		"    int l = 0, r = 0;",
		"    for(int i = 1; i < n; i++) {",
		"        if(i < r) {",
		"            z[i] = min(r - i, z[i - l]);",
		"        }",
		"        while(i + z[i] < n && s[z[i]] == s[i + z[i]]) {",
		"            z[i]++;",
		"        }",
		"        if(i + z[i] > r) {",
		"            l = i;",
		"            r = i + z[i];",
		"        }",
		"    }",
		"    return z;",
		"}"
	],
	"description": "Z Algorithm"
	},
	
	"Binary Exponentiation": {
		"prefix": "binpow",
		"body": [
			"long long binpow(long long a, long long b, long long m) {",
			"    assert(b >= 0);",
			"    a %= m;",
			"    long long res = 1;",
			"    while (b) {",
			"        if (b & 1) res = res * a % m;",
			"        a = a * a % m;",
			"        b /= 2;",
			"    }",
			"    return res;",
			"}"
		],
		"description": "Binary Exponentiation"
	},

	"Manacher's Algorithm": {
	"prefix": "manacher",
	"body": [
		"void manacher(string s){",
		"  int n = s.size();",
		"  p.assign(n, 1);",
		"  int l = 1, r = 1;",
		"  for(int i = 1; i < n; ++i){",
		"    p[i] = max(0, min(r - i, p[l + r - i]));",
		"    while(i + p[i] < n && i - p[i] >= 0 && s[i + p[i]] == s[i - p[i]]) p[i]++; // bounding box",
		"    if(i + p[i] > r){",
		"      l = i - p[i];",
		"      r = i + p[i];",
		"    }",
		"  }",
		"}",
		"",
		"int getLongest(int centre, bool odd){",
		"  int pos = 2 * centre + 1 + (!odd);",
		"  return p[pos] - 1;",
		"}",
		"",
		"bool checkPalindrome(int l, int r){",
		"  if((r - l + 1) <= getLongest((l + r) / 2, l % 2 == r % 2)) return true;",
		"  return false;",
		"}",
		""
	],
	"description": "Manacher's Algorithm"
	},

	"Trie Data Structure": {
	"prefix": "_trie",
	"body": [
		"class TrieNode{",
		"public:",
		"    TrieNode* links[26];",
		"    int wordsStartingWith = 0;",
		"    int wordsEndingWith = 0;",
		"    bool flag = false;",
		"    bool containsKey(char ch){",
		"        return links[ch - 'a'] != NULL;",
		"    }",
		"    void put(char ch, TrieNode* node){",
		"        links[ch - 'a'] = node;",
		"    }",
		"    TrieNode* get(char ch){",
		"        return links[ch - 'a'];",
		"    }",
		"    void setEnd(){",
		"        flag = true;",
		"    }",
		"    bool isEnd(){",
		"        return flag;",
		"    }",
		"};",
		"",
		"class Trie {",
		"public:",
		"    TrieNode* root;",
		"    Trie() {",
		"        root = new TrieNode();",
		"    }",
		"    ",
		"    void insert(string word) {",
		"        TrieNode* node = root;",
		"        for(int i = 0; i < word.size(); i++){",
		"            if(!node -> containsKey(word[i])){",
		"                node -> put(word[i], new TrieNode());",
		"            }",
		"            node = node -> get(word[i]);",
		"            node -> wordsStartingWith++;",
		"        }",
		"        node -> wordsEndingWith++;",
		"        node -> setEnd();",
		"    }",
		"",
		"    bool search(string word) {",
		"        TrieNode* node = root;",
		"        for(int i = 0; i < word.size(); i++){",
		"            if(!node -> containsKey(word[i])) return false;",
		"            node = node -> get(word[i]);",
		"        }",
		"        return node -> isEnd();",
		"    }",
		"    ",
		"    bool startsWith(string prefix) {",
		"        TrieNode* node = root;",
		"        for(int i = 0; i < prefix.size(); i++){",
		"            if(!node -> containsKey(prefix[i])) return false;",
		"            node = node -> get(prefix[i]);",
		"        }",
		"        return true;",
		"    }",
		"",
		"    int countWordsEqualTo(string word) {",
		"        TrieNode* node = root;",
		"        for(int i = 0; i < word.size(); i++){",
		"            if(!node -> containsKey(word[i])){",
		"                return 0;",
		"            }",
		"            node = node -> get(word[i]);",
		"        }",
		"        return node -> wordsEndingWith;",
		"    }",
		" int countWordsStartingWith(string prefix) {",
		"        TrieNode* node = root;",
		"        for(int i = 0; i < prefix.size(); i++){",
		"            if(!node -> containsKey(prefix[i])){",
		"                return 0;",
		"            }",
		"            node = node -> get(prefix[i]);",
		"        }",
		"        return node -> wordsStartingWith;",
		"    }",
		"    ",
		"    void erase(string word) {",
		"        TrieNode* node = root;",
		"        for(int i = 0; i < word.size(); i++){",
		"            if(!node -> containsKey(word[i])) return;",
		"            node = node -> get(word[i]);",
		"            node -> wordsStartingWith--;",
		"        }",
		"        node -> wordsEndingWith--;",
		"    }",
		"};",
		""
	],
	"description": "Trie Data Structure"
	},

	"BinaryIndexedTree ": {
	"prefix": "_bit",
	"body": [
		"class BinaryIndexedTree {",
		"private:",
		"    int treeSize;",
		"    std::vector<int> tree;",
		"",
		"public:",
		"    // Constructor initializes the binary indexed tree with a given size",
		"    explicit BinaryIndexedTree(int size)",
		"        : treeSize(size), tree(size + 1, 0) {}",
		"",
		"    // Updates the tree at position index by value",
		"    void update(int ind, int value) {",
		"        for ( ;ind <= treeSize; ind += ind & -ind) tree[ind] += value;",
		"    }",
		"",
		"    // Queries the cumulative frequency up to position index",
		"    int query(int ind) {",
		"        int sum = 0;",
		"        for ( ;ind > 0; ind -= ind & -ind) sum += tree[ind];",
		"        return sum;",
		"    }",
		"};",
		""
	],
	"description": "BinaryIndexedTree "
	},

	"Prime Factors": {
	"prefix": "_prime_factor",
	"body": [
		"vector<int> primeFactor(int n){",
		"    vector<int> factor;",
		"    for(int i = 2; i * i <= n; ++i){",
		"        while(n % i == 0){",
		"            factor.push_back(i);",
		"            n = n / i;",
		"        }",
		"    }",
		"    if(n > 1) factor.push_back(n);",
		"    return factor;",
		"}",
		""
	],
	"description": "Prime Factors"
	},

	"Sieve of Eratosthenes": {
	"prefix": "_sieve",
	"body": [
		"vector<int> sieve(1e6 + 1);",
		"//sieve[u] = 0  ---> prime number",
		"//sieve[u] = x  ---> composite number that stores the highest prime factor",
		"// TC -> N * logN",
		"void primeSieve(int n){",
		"    for (int x = 2; x <= n; x++){",
		"        if (sieve[x]) continue; // Not a prime",
		"        for (int u = 2 * x; u <= n; u += x){",
		"            sieve[u] = x;  // sieve[u] stores the highest prime factor of u",
		"        }",
		"    }",
		"}"
	],
	"description": "Sieve of Eratosthenes"
	},

	"Check Prime Number": {
	"prefix": "_is_prime",
	"body": [
		"bool isPrime(int x)",
		"{",
		"    for (int i = 2; i * i <= x; i++)",
		"        if (x % i == 0)",
		"            return false;",
		"    return true;",
		"}"
	],
	"description": "Check Prime Number"
	},

	"Divisors": {
	"prefix": "_divisors",
	"body": [
		"vector<int> divisors(long long num){",
		"    vector<int> factors;",
		"    for(int i = 1; i * i <= num; ++i){",
		"        if(num % i == 0){",
		"            factors.push_back(i);",
		"            if(i != num / i) factors.push_back(num/i);",
		"        }",
		"    }",
		"    return factors;",
		"}"
	],
	"description": "Divisors"
	},

	"Build nCr Table": {
	"prefix": "_build_nCr_table",
	"body": [
		"long long ncr[2000][2000];",
		"// Builds nCr % m table",
		"// TC: N * N : works for Non Prime valus as well",
		"void _build_nCr_table_mod(long long n, long long m){",
		"    memset(ncr, 0, sizeof(ncr));                                // dp[i][j] will hold C(i, j) % m    ",
		"    for(long long i = 0; i <= n; ++i) ncr[i][0] = 1;            // Base cases: C(i, 0) = 1    ",
		"    for(long long i = 1; i <= n; ++i){                          // Fill the table row by row        ",
		"        for(long long j = 1; j <= min(i, n) ; ++j){            // Only need to fill upto j <= min(i, r)",
		"            ncr[i][j] = (ncr[i - 1][j] + ncr[i - 1][j - 1]) % m;",
		"        }",
		"    }",
		"}"
	],
	"description": "Build nCr Table"
	},

	"nCr": {
	"prefix": "_nCr",
	"body": [
		"long long fact[MAX];",
		"long long invFact[MAX];",
		"",
		"// Fast exponentiation: (base^exp) % MOD",
		"long long power(long long base, long long exp) {",
		"    long long result = 1;",
		"    base %= MOD;",
		"    while (exp > 0) {",
		"        if (exp & 1) result = (result * base) % MOD;",
		"        base = (base * base) % MOD;",
		"        exp >>= 1;",
		"    }",
		"    return result;",
		"}",
		"",
		"// Precompute factorials and inverse factorials",
		"void precompute() {",
		"    fact[0] = invFact[0] = 1;",
		"",
		"    for (int i = 1; i < MAX; i++) {",
		"        fact[i] = (fact[i - 1] * i) % MOD;",
		"    }",
		"",
		"    // invFact[n] = (fact[n])^(MOD-2) % MOD",
		"    invFact[MAX - 1] = power(fact[MAX - 1], MOD - 2);",
		"",
		"    for (int i = MAX - 2; i >= 1; i--) {",
		"        invFact[i] = (invFact[i + 1] * (i + 1)) % MOD;",
		"    }",
		"}",
		"",
		"long long nCr(int n, int r) {",
		"    if (r < 0 || r > n) return 0;",
		"    return fact[n] * invFact[r] % MOD * invFact[n - r] % MOD;",
		"}"
	],
	"description": "nCr"
	},

	"nCr table": {
	"prefix": "nCr",
	"body": [
		"// Fast exponentiation: (base^exp) % MOD",
		"// TC : logN",
		"long long power(long long base, long long exp) {",
		"    long long result = 1;",
		"    base %= MOD;",
		"    while (exp > 0) {",
		"        if (exp & 1) result = (result * base) % MOD;",
		"        base = (base * base) % MOD;",
		"        exp >>= 1;",
		"    }",
		"    return result;",
		"}",
		"",
		"const int FACT_SIZE = 1e7 + 5;",
		"long long invFact[FACT_SIZE];",
		"long long fact[FACT_SIZE];",
		"",
		"// Precompute factorials and inverse factorials",
		"void build_Factorial_And_Inverse() {",
		"    fact[0] = invFact[0] = 1;",
		"",
		"    for (int i = 1; i < FACT_SIZE; i++) {",
		"        fact[i] = (fact[i - 1] * i) % MOD;",
		"    }",
		"",
		"    // invFact[n] = (fact[n])^(MOD-2) % MOD",
		"    invFact[FACT_SIZE - 1] = power(fact[FACT_SIZE - 1], MOD - 2);",
		"",
		"    for (int i = FACT_SIZE - 2; i >= 1; i--) {",
		"        invFact[i] = (invFact[i + 1] * (i + 1)) % MOD;",
		"    }",
		"}",
		"",
		"// returns nCr value",
		"// TC : O(1) works only for prime mod",
		"ll nCr(ll n, ll r) {",
		"    if (r < 0 || r > n) return 0;",
		"",
		"    ll num = 1, den = 1;",
		"    for (ll i = 0; i < r; ++i) {",
		"        num = (num * (n - i)) % MOD;",
		"        den = (den * (i + 1)) % MOD;",
		"    }",
		"    return (num * power(den, MOD - 2)) % MOD;",
		"}"
	],
	"description": "nCr table"
	},

	"nCr value": {
	"prefix": "nCr_",
	"body": [
		"// returns actual value of nCr",
		"// can be used upto n = 30 otherwise it may give wrong answers",
		"// TC: logN per call",
		"long long ncr(int n, int r){",
		"    if(r < 0 || r > n) return 0;",
		"    if(r > n - r) r = n - r;",
		"    long long result = 1;",
		"    for(int i = 1; i <= r; ++i){",
		"        result = result * (n - i + 1) / i;",
		"    }",
		"    return result;",
		"}"
	],
	"description": "nCr value"
	}
}
